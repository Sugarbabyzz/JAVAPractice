### 一、 目的

​	利用**历史记录**，来避免重复计算。

​	**历史记录**：通常使用一些变量来保存，一般是用**一位数组**或者**二维数组**。

### 二、 三大步骤

>#### 第一步：定义数组元素的含义。
>
>​	使用一个数组，来保存历史数组。
>
>​	假设用一维数组dp[]，需要规定这个dp数组元素的含义。
>
>#### 第二步：找出数组元素之间的关系式。
>
>​	利用**历史数据**来推出新的元素值。
>
>​	例如要计算 dp[n] 时，可以利用 dp[n-1]、dp[n-2]......dp[n] 的值。
>
>#### 第三步：找出初始值。
>
>​	如果由 dp[n] = dp[n-1] + dp[n-2] 递推计算，则最后为 dp[3] = dp[1] + dp[2]，dp[1] 和 dp[2] 是不可分解的元素，必须获得这两个的值，即**所谓的初始值**。

根据以上步骤，有了**初始值**，以及**数组元素之间的关系式**，就可以得到 dp[n] 的值了。

dp[n] 的含义由自己定义，想**求什么，就定义它是什么**。

### 三、案例分析

#### 案例一、简单的一维DP

>问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法？

**（1）定义数组元素的含义**

​	dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**。

**（2）找出数组元素间的关系式（最核心最难）**

​	必须回到问题本身，来寻找他们的关系。

​	对于本题，由于只能跳 1 级或者跳 2 级，所以要达到第 n 级的台阶有两种方式，一种是从 n-1 级跳上来，一种是从 n-2 级跳上来。

​	所以要**算所有可能的跳法**，有 **dp[n] = dp[n-1] + dp[n-2]** 。

**（3）找出初始值**

​	当 n = 1 时，dp[1] = dp[0] + dp[-1]，由于下标不能为负，所以对于 dp[1]，必须**直接给出其数值**，显然 dp[1] = 1。同样的，dp[0] = 0（因为 0 个台阶，肯定是 0 种跳法）。

```java
public int climbStairs(int n) {
  int[] dp = new int[n + 1];
  dp[0] = 1;  // dp[0] = 0 是错误的，设置初始值不严谨
  dp[1] = 1;
  for (int i = 2; i < n; i++) {
    dp[n] = dp[n-1] + dp[n-2];
  }
  return dp[n];
}
```

**（4）再谈初始化**

​	其实上面的初始值设定是有问题的，错在**对初始值的寻找不够严谨**。	

​	如果 dp[0] = 0，则 dp[2] = dp[1] + dp[0] = 1，显然是错误的， 根据模拟，dp[2] =2。	

#### 案例二、二维数组的 DP

动态规划 80% 的题，都需要用二维数组。

>问题描述：一个机器人位于一个 m x n 的网格左上角（Start），机器人每次只能向下或者向右移动一步，机器人试图达到网络的右下角（Finish）。问总共有多少条不同的路径？
>
><img src="/Users/sugar/Library/Application Support/typora-user-images/image-20200810102800708.png" alt="image-20200810102800708" style="zoom:20%;" />
>
>例如，如图是一个 7 x 3 的网格，有多少种可能的路径？
>
>**说明**：m 和 n 的值均不超过 100.

**（1）定义数组元素的含义**

​	dp\[i\]\[j\] 的含义为：**当机器人走到 (i,j) 这个位置时，一共有 dp[i][j\] 种路径**。

>dp\[m-1\]\[n-1\] 是需要的答案。
>
>这个网格相当于一个二维数组，数组是从下标 0 开始计算的。所有右下角的位置时 （m-1, n-1）。

**（2）找出数组元素间的关系式**

​	对于本题，由于机器人只能向下走或者向右走，所以有两种方式可以到达右下角。一种是从（i-1, j）这个位置向右走一步，一种是从（i, j-1）这个位置向下走一步。

​	将**所有可能的路径加起来**，关系式是 **dp\[i\]\[j\] = dp\[i-1\]\[j\] + dp\[i\]\[j-1\]** 。	

**（3）找出初始值**

​	在 dp\[i\]\[j\] 中，如果 i 或者 j 有一个为 0，则 i-1 或 j-1时，数组下标就为负数了，数组就会出现问题。

​	所以初始值是计算出所有的 **dp\[0\]\[0...n-1\]** 和所有的 **dp\[0....m-1\]\[0\]**，相当于图中的最上面一行和最左边一列。因此初始值如下：

​	**dp\[0\]\[0...n-1\]**  = 1  // 相当于最上面一行，机器人只能一直往右走

​	**dp\[0....m-1\]\[0\]** = 1  // 相当于最左边一列，机器人只能一直往下走

```java
public int uniquePaths(int m, int n) {
      if (m <= 0 || n <= 0)
        return 0;

      int[][] dp = new int[m][n];
      for (int i = 0; i < m; i++)
        dp[i][0] = 1;
      for (int i = 0; i < n; i++)
        dp[0][i] = 1;

      for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
          dp[i][j] = dp[i-1][j] + dp[i][j-1];

      return dp[m-1][n-1];
}
```

#### 案例三、二维数组的DP

> 给定一个包含非负整数的  m x n 网格，找出一条从左上角到右下角的路径，使路径上的数字总和为最小。
>
> **说明**：每次只能向下或者向右移动一步。

	>```java
	>举例：
	>输入:
	>arr = [
	>  [1,3,1],
	>  [1,5,1],
	>  [4,2,1]
	>]
	>输出: 7
	>解释: 因为路径 1→3→1→1→1 的总和最小。
	>```

**（1）定义数组元素的含义**

​	dp\[i\]\[j\] 的含义为：**当机器人走到 (i,j) 这个位置时，最小路径和为 dp[i][j\] **。

>dp\[m-1\]\[n-1\] 是需要的答案。
>
>这个网格相当于一个二维数组，数组是从下标 0 开始计算的。所有右下角的位置时 （m-1, n-1）。

**（2）找出数组元素间的关系式**

​	同样，对于本题，由于机器人只能向下走或者向右走，所以有两种方式可以到达右下角。一种是从（i-1, j）这个位置向右走一步，一种是从（i, j-1）这个位置向下走一步。

​	**计算哪一个路径和是最小的**，关系式是 **dp\[i\]\[j\] = min（dp\[i-1\]\[j\],  dp\[i\]\[j-1\]） + arr\[i\]\[j\] ** 。

**（3）找出初始值**

​	同样的，将图中的最上面一行和最左边一列初始化。

​	**dp\[0\]\[j\]**  = arr\[0\]\[j\] + dp\[0\]\[j-1\]  // 相当于最上面一行，机器人只能一直往右走

​	**dp\[i\]\[0\]** = arr\[i\]\[0\] + dp\[i-1\]\[0\]  // 相当于最左边一列，机器人只能一直往下走

