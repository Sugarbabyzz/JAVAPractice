### 一、 目的

​	利用**历史记录**，来避免重复计算。

​	**历史记录**：通常使用一些变量来保存，一般是用**一位数组**或者**二维数组**。

### 二、 三大步骤

>#### 第一步：定义数组元素的含义。
>
>​	使用一个数组，来保存历史数组。
>
>​	假设用一维数组dp[]，需要规定这个dp数组元素的含义。
>
>#### 第二步：找出数组元素之间的关系式。
>
>​	利用**历史数据**来推出新的元素值。
>
>​	例如要计算 dp[n] 时，可以利用 dp[n-1]、dp[n-2]......dp[n] 的值。
>
>#### 第三步：找出初始值。
>
>​	如果由 dp[n] = dp[n-1] + dp[n-2] 递推计算，则最后为 dp[3] = dp[1] + dp[2]，dp[1] 和 dp[2] 是不可分解的元素，必须获得这两个的值，即**所谓的初始值**。

根据以上步骤，有了**初始值**，以及**数组元素之间的关系式**，就可以得到 dp[n] 的值了。

dp[n] 的含义由自己定义，想**求什么，就定义它是什么**。

### 三、案例分析

#### 案例一、简单的一维DP

>**问题描述：**一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法？

**（1）定义数组元素的含义**

​	dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**。

**（2）找出数组元素间的关系式（最核心最难）**

​	必须回到问题本身，来寻找他们的关系。

​	对于本题，由于只能跳 1 级或者跳 2 级，所以要达到第 n 级的台阶有两种方式，一种是从 n-1 级跳上来，一种是从 n-2 级跳上来。

​	所以要**算所有可能的跳法**，有 **dp[n] = dp[n-1] + dp[n-2]** 。

**（3）找出初始值**

​	当 n = 1 时，dp[1] = dp[0] + dp[-1]，由于下标不能为负，所以对于 dp[1]，必须**直接给出其数值**，显然 dp[1] = 1。同样的，dp[0] = 0（因为 0 个台阶，肯定是 0 种跳法）。

```java
public int climbStairs(int n) {
  int[] dp = new int[n + 1];
  dp[0] = 1;  // dp[0] = 0 是错误的，设置初始值不严谨
  dp[1] = 1;
  for (int i = 2; i < n; i++) {
    dp[n] = dp[n-1] + dp[n-2];
  }
  return dp[n];
}
```

**（4）再谈初始化**

​	其实上面的初始值设定是有问题的，错在**对初始值的寻找不够严谨**。	

​	如果 dp[0] = 0，则 dp[2] = dp[1] + dp[0] = 1，显然是错误的， 根据模拟，dp[2] =2。	

#### 案例二、二维数组的 DP

动态规划 80% 的题，都需要用二维数组。

>**问题描述：**一个机器人位于一个 m x n 的网格左上角（Start），机器人每次只能向下或者向右移动一步，机器人试图达到网络的右下角（Finish）。问总共有多少条不同的路径？
>
><img src="/Users/sugar/Library/Application Support/typora-user-images/image-20200810102800708.png" alt="image-20200810102800708" style="zoom:20%;" />
>
>例如，如图是一个 7 x 3 的网格，有多少种可能的路径？
>
>**说明**：m 和 n 的值均不超过 100.

**（1）定义数组元素的含义**

​	dp\[i\]\[j\] 的含义为：**当机器人走到 (i,j) 这个位置时，一共有 dp[i][j\] 种路径**。

>dp\[m-1\]\[n-1\] 是需要的答案。
>
>这个网格相当于一个二维数组，数组是从下标 0 开始计算的。所有右下角的位置时 （m-1, n-1）。

**（2）找出数组元素间的关系式**

​	对于本题，由于机器人只能向下走或者向右走，所以有两种方式可以到达右下角。一种是从（i-1, j）这个位置向右走一步，一种是从（i, j-1）这个位置向下走一步。

​	将**所有可能的路径加起来**，关系式是 **dp\[i\]\[j\] = dp\[i-1\]\[j\] + dp\[i\]\[j-1\]** 。	

**（3）找出初始值**

​	在 dp\[i\]\[j\] 中，如果 i 或者 j 有一个为 0，则 i-1 或 j-1时，数组下标就为负数了，数组就会出现问题。

​	所以初始值是计算出所有的 **dp\[0\]\[0...n-1\]** 和所有的 **dp\[0....m-1\]\[0\]**，相当于图中的最上面一行和最左边一列。因此初始值如下：

​	**dp\[0\]\[0...n-1\]**  = 1  // 相当于最上面一行，机器人只能一直往右走

​	**dp\[0....m-1\]\[0\]** = 1  // 相当于最左边一列，机器人只能一直往下走

```java
public int uniquePaths(int m, int n) {
      if (m <= 0 || n <= 0)
        return 0;

      int[][] dp = new int[m][n];
      for (int i = 0; i < m; i++)
        dp[i][0] = 1;
      for (int i = 0; i < n; i++)
        dp[0][i] = 1;

      for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
          dp[i][j] = dp[i-1][j] + dp[i][j-1];

      return dp[m-1][n-1];
}
```

#### 案例三、二维数组的DP

> **问题描述：**给定一个包含非负整数的  m x n 网格，找出一条从左上角到右下角的路径，使路径上的数字总和为最小。
>
> **说明**：每次只能向下或者向右移动一步。

	>```java
	>举例：
	>输入:
	>arr = [
	>  [1,3,1],
	>  [1,5,1],
	>  [4,2,1]
	>]
	>输出: 7
	>解释: 因为路径 1→3→1→1→1 的总和最小。
	>```

**（1）定义数组元素的含义**

​	dp\[i\]\[j\] 的含义为：**当机器人走到 (i,j) 这个位置时，最小路径和为 dp[i][j\] **。

>dp\[m-1\]\[n-1\] 是需要的答案。
>
>这个网格相当于一个二维数组，数组是从下标 0 开始计算的。所有右下角的位置时 （m-1, n-1）。

**（2）找出数组元素间的关系式**

​	同样，对于本题，由于机器人只能向下走或者向右走，所以有两种方式可以到达右下角。一种是从（i-1, j）这个位置向右走一步，一种是从（i, j-1）这个位置向下走一步。

​	**计算哪一个路径和是最小的**，关系式是 **dp\[i\]\[j\] = min（dp\[i-1\]\[j\],  dp\[i\]\[j-1\]） + arr\[i\]\[j\] ** 。

**（3）找出初始值**

​	同样的，将图中的最上面一行和最左边一列初始化。

​	**dp\[0\]\[j\]**  = arr\[0\]\[j\] + dp\[0\]\[j-1\]  // 相当于最上面一行，机器人只能一直往右走

​	**dp\[i\]\[0\]** = arr\[i\]\[0\] + dp\[i-1\]\[0\]  // 相当于最左边一列，机器人只能一直往下走

#### 案例四、二维数组的DP

> **问题描述：**给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的的最少操作数。
> 可以对一个单词进行如下三种操作：插入、删除和替换。

> ```java
> 示例：
> 输入: word1 = "horse", word2 = "ros"
> 输出: 3
> 解释: 
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')
> ```

**（1）定义数组元素的含义**

​	本题的目的是求将 word1 转换成 word2 所使用的的最少操作数。

​	定义 dp\[i\]\[j\] 的含义为：**当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，dp\[i\]\[j\] 为 word1 转换为 word2 所使用的的最少操作次数。**

**（2）找出数组元素间的关系式**

​	相比其他题来说，这道题的元素关系难找一点，但无论如何，**dp\[i\]\[j\] 和 dp\[i-1\]\[j\]、dp\[i\]\[j-1\]、dp\[i-1\]\[-1j\] 之间肯定是存在某种关系的**。

​	我们的目标就是，**从规模小的，通过一些操作，推导出规模大的**。

​	关系式：

1. **如果 word1[i] 与 word2[j] 相等**，则不需要进行任何操作，显然有 dp\[i\]\[j\] = dp\[i-1\]\[j-1\]。

2. **如果 word1[i] 与 word2[j] 不相等**，则必须进行调整，有三种操作（插入、删除和替换），三种方式对应的关系如下：

   **替换**：如果将字符 word1[i] 替换成与 word2[j] 相等的，则有 dp\[i\]\[j\] = dp\[i-1\]\[j-1\] + 1；

   **插入**：如果在字符串 word1 末尾插入一个与 word2[j] 相等的字段，则有 dp\[i\]\[j\] = dp\[i\]\[j-1\] + 1；

   **删除**：如果把字符 word1[i] 删除，则有 dp\[i\]\[j\] = dp\[i-1\]\[j\] + 1。

那么应该选择一种操作，使得 dp\[i\]\[j\] 的值最小，显然有：

​	**dp\[i\]\[j\] = min（dp\[i-1\]\[j-1\]，dp\[i\]\[j-1\]，dp\[i-1\]\[j\]） + 1**

**（3）找出初始值**

​	显然，在 dp\[i\]\[j\] 中，i 或 j 不能为0。

​	所以初始值是要计算出所有的 **dp\[0....m-1\]\[0\]** 和所有的 **dp\[0\]\[0...n-1\]**。

​	当一个字符串长度为 0 时，转化为另一个字符串，就只能一直进行插入或删除操作了。

```java
public int minDistance(String word1, String word2) {
  	int n1 = word1.length();
  	int n2 = word2.length();

  	int[][] dp = new int[n1 + 1][n2 + 1];
	  dp[0][0] = 0;

    for (int i = 1; i <= n1; i++)
      dp[i][0] = dp[i - 1][0] + 1;
    for (int i = 1; i <= n2; i++)
      dp[0][i] = dp[0][i-1] + 1;

    for (int i = 1; i <= n1; i++)
      for (int j = 1; j <= n2; j++) {
        if (word1.charAt(i-1) == word2.charAt(j-1)) {
          dp[i][j] = dp[i-1][j-1];
        } else {
          dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i][j-1]), dp[i-1][j]) + 1;
        }
      }

	  return dp[n1][n2];
}
```

