### 1 简介

> 什么是设计模式

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303192737068.png" alt="image-20210303192737068" style="zoom:40%;" />

> 学习设计模式的意义

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303192852485.png" alt="image-20210303192852485" style="zoom:40%;" />

> 设计模式的基本要素

比如，单例模式，是为了解决系统开销问题。

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303192959365.png" alt="image-20210303192959365" style="zoom:40%;" />

> GoF23



<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303193144336.png" alt="image-20210303193144336" style="zoom:40%;" />

## 2 OOP七大原则

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303193344874.png" alt="image-20210303193344874" style="zoom:40%;" />

- 开闭原则：当业务需求发生变化，尽可能不修改原有代码，可以在上面进行扩展。
- 里氏替换原则：子类能够扩展父类的功能，但是不要修改父类原有的功能。
- 依赖倒置原则：降低程序之间的耦合性。
- 单一职责原则：一个方法尽量做一件事。
- 接口隔离原则：尽可能将类细化。
- 迪米特法则：代理模式。
- 合成复用原则：和里氏替换原则相辅相成，都是开闭原则的实现。

### 3 单例模式

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303202009909.png" alt="image-20210303202009909" style="zoom:40%;" />

饿汉式、DCL懒汉式

> 饿汉式

```java
package com.sugar.singleton;

/**
 * 饿汉式单例
 * 一上来就加载所有资源，会造成空间浪费 -> 懒汉式，需要时再加载
 */
public class Hungry {

    // 可能会浪费空间
    private byte[] data1 = new byte[1024*1024];
    private byte[] data2 = new byte[1024*1024];
    private byte[] data3 = new byte[1024*1024];
    private byte[] data4 = new byte[1024*1024];


    private Hungry() {

    }

    private final static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance() {
        return HUNGRY;
    }
}
```

> DCL懒汉式

```java
package com.sugar.singleton;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

/**
 * 懒汉式单例
 */
public class LazyMan {

    // 信号量，防止未调用getInstance，直接用两个反射破坏单例
    private static boolean sugar = false;

    private LazyMan() {
        // 三重，防止反射
//        synchronized (LazyMan.class) {
//            if (lazyMan != null) {
//                throw new RuntimeException("不要试图使用反射破坏单例！");
//            }
//        }

        // 更进一步，用信号量
        synchronized (LazyMan.class) {
            if (sugar == false) {
                sugar = true;
            } else {
                throw new RuntimeException("不要试图使用反射破坏单例！");
            }
        }
    }

    private volatile static LazyMan lazyMan;

    // 双重检测锁模式的 懒汉式单例 DCL懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();  // 不是一个原子性操作
                }
            }
        }
        return lazyMan;
    }

    /**
     * 1. 分配内存空间
     * 2. 执行构造方法，初始化对象
     * 3. 把这个对象指向这个空间
     *
     * 123
     * 132  A
     *      B  // 此时LazyMan还没有完成构造
     */
    // 单线程可以，多线程并发存在问题
//    public static void main(String[] args) {
//        for (int i = 0; i < 10; i++) {
//            new Thread(() -> {
//                LazyMan.getInstance();
//            }).start();
//        }
//    }

    /**
     * 利用反射破坏单例！
     */
    public static void main(String[] args) throws Exception {
        // 三重
//        LazyMan instance = LazyMan.getInstance();

        // final 修改 sugar 属性  ==>>  枚举 ENUM
        Field sugar = LazyMan.class.getDeclaredField("sugar");
        sugar.setAccessible(true);

        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        // 更进一步
        LazyMan instance = declaredConstructor.newInstance();

        sugar.set(instance, false);
        LazyMan instance2 = declaredConstructor.newInstance();



        System.out.println(instance);  // instance不同
        System.out.println(instance2);


    }
}
```

> 静态内部类

```java
package com.sugar.singleton;

/**
 * 静态内部类实现单例
 */
public class Holder {

    private Holder() {

    }

    public static Holder getInstance() {
        return InnerClass.HOLDER;
    }

    public static class InnerClass {
        private  static final Holder HOLDER = new Holder();
    }
}
```

##### 因为反射的存在，单例并不安全，因此枚举上场。

**枚举类型的最终反编译源码，两个参数的有参构造**

```java
package com.sugar.singleton;

import java.lang.reflect.Constructor;

/**
 * 枚举单例
 * enum 是什么？本身也是一个 Class 类
 */
public enum EnumSingle {

    INSTANCE;

    public EnumSingle getInstance() {
        return INSTANCE;
    }
}

class Test {
    public static void main(String[] args) throws Exception {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        EnumSingle instance2 = EnumSingle.INSTANCE;

        System.out.println(instance1);
        System.out.println(instance2);

        // NoSuchMethodException 没有无参构造方法
//        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);
        // 经过反编译后，发现Enum 构造器有两个参数
        // 运行后，彻底说明，反射不能破坏枚举的单例  Cannot reflectively create enum objects
        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);
        declaredConstructor.setAccessible(true);
        EnumSingle instance3 = declaredConstructor.newInstance();
        System.out.println(instance3);
    }
}
```



### 4 工厂模式

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303202134292.png" alt="image-20210303202134292" style="zoom:40%;" />

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303202327441.png" alt="image-20210303202327441" style="zoom:40%;" />

>  简单工厂模式

静态工厂模式（简单工厂模式）
*    方法都是静态的，通过传入不同参数，返回不同实例
*    弊端：增加一个新的产品，必须要修改工厂代码！
* 但在大多数情况下，使用简单工厂模式，为了遵循开闭原则，需要付出许多代价。

<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303205105064.png" alt="image-20210303205105064" style="zoom:30%;" />

Car接口类

```java
package factory.simple;

public interface Car {
    void name();
}
```

两个Car

```java
package factory.simple;

public class Tesla implements Car{
    @Override
    public void name() {
        System.out.println("特斯拉！");
    }
}
```

```java
package factory.simple;

public class Benz implements Car{
    @Override
    public void name() {
        System.out.println("奔驰！");
    }
}
```

Car工厂类

```java
package factory.simple;

/**
 * 静态工厂模式（简单工厂模式）
 *    方法都是静态的，通过传入不同参数，返回不同实例
 *    弊端：增加一个新的产品，必须要修改工厂代码！
 * 但在大多数情况下，使用简单工厂模式，为了遵循开闭原则，需要付出许多代价。
 */
public class CarFactory {

    // 方法一：违反开闭原则
    public static Car getCar(String car) {
        if (car.equals("奔驰")) {
            return new Benz();
        } else if (car.equals("特斯拉")) {
            return new Tesla();
        } else {
            return null;
        }
    }

    // 方法二：优化，但还是在修改工厂类
    public static Car getBenz() {
        return new Benz();
    }
    public static Car getTesla() {
        return new Tesla();
    }
}
```

消费者

```java
package factory.simple;

public class Consumer {
    public static void main(String[] args) {
        // 1. 原来的方式
        // 需要去了解接口、所有的实现类！
//        Car car = new Benz();
//        Car car2 = new Tesla();

        // 2. 使用工厂创建工厂方式
        Car car = CarFactory.getCar("奔驰");
        Car car2 = CarFactory.getCar("特斯拉");
        car.name();
        car2.name();

        // 缺点：再增加一个大众，需要修改工厂代码，违反了开闭原则
    }
}
```



>  工厂方法模式

工厂方法模式
*    为每个实例都创建了一个工厂
*    扩展自由

CarFactory接口

```java
package factory.method;

import factory.method.Car;

/**
 * 工厂方法模式
 *    为每个实例都创建了一个工厂
 *    扩展自由
 */
public interface CarFactory {
    Car getCar();
}
```

CarFactory实现

```java
package factory.method;

public class BenzFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Benz();
    }
}
```

消费者

```java
package factory.method;

public class Consumer {
    public static void main(String[] args) {
        Car car = new BenzFactory().getCar();
        Car car2 = new TeslaFactory().getCar();
        car.name();
        car2.name();

        // 新增一个摩拜，无需修改原工厂代码
        Car car3 = new MobaiFactory().getCar();
        car3.name();
    }
}
```



**对比简单工厂和工厂方法**：

​	结构复杂度：简单 > 方法

​	代码复杂度：简单 > 方法

​	编程复杂度：简单 > 方法

​	管理复杂度：简单 > 方法

总结：根据设计原则，工厂方法模式！但根据实际业务，简单工厂模式！

>  抽象工厂模式





<img src="/Users/sugar/Library/Application Support/typora-user-images/image-20210303210938888.png" alt="image-20210303210938888" style="zoom:40%;" />